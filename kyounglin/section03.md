## 수동 테스트의 한계

1. 프린트된 메시지를 수동으로 확인하는 방법은 불편하다.
2. 사용자 웹 UI까지 개발한 뒤에 확인하는 방법은 테스트가 실패했을 때 확인할 코드가 많다.
3. 테스트할 대상이 많아질수록 검증하는데 시간이 많이 걸리고 부정확함.

## 작은 크기의 자동 수행되는 테스트

### 개발자가 만드는 테스트

- 개발한 코드에 대한 검증 기능을 코드로 작성한다.
- 자동으로 테스트를 수행하고 결과를 확인한다.
- 테스팅 프레임워크를 활용한다.
- 테스트 작성과 실행도 개발 과정의 일부이다.

## JUnit 5

- `@Test` 테스트 메소드
- `@BeforeEach` 메소드
- 테스트마다 각 새로운 인스턴스가 만들어진다.

`@BeforeEach`는 각 테스트 전에 수행되는 것이다.

위 코드에서는 테스트 메소드가 3개라면, 3번의 테스트 메소드 전에 각각의 새로운 오브젝트를 생성한다.

그렇다면, 우리가 제어할 수 없는 외부 시스템에 문제가 생기면?

## 테스트의 구성요소

- 테스트 - 테스트 대상 (SUT) - 협력자 (오브젝트)

### 문제점: 협력자가 이용하는 외부 API에서 문제가 생기면?

### Stub

- 테스트 하는 동안만 협력자를 대체하여 사용됨 (임포스터, Test Double(대역))

### 수동 DI를 이용하는 테스트

- 테스트용 협력자 / 의존 오브젝트를 테스트 대상에 직접 주입하고 테스트.

### 스프링 DI를 이용하는 테스트

- 테스트용 협력자 / 의존 오브젝트를 스프링의 구성 정보를 이용해서 지정하고 컨테이너로부터 테스트 대상을 가져와서 테스트.

```java
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = TestObjectFactory.class)
@Autowired
PaymentService paymentService;
```
## 학습 테스트

- 직접 만들지 않은 코드, 라이브러리, 레거시 시스템에 대한 테스트
- 테스트 대상의 사용방법을 익히고 동작방식을 확인하는데 유용하다.
- 외부 기술, 서비스가 버전이 올라갔을 때 이전과 동일하게 동작하는지 확인할 수도 있다.

## 테스트 - 대상 - Stub, Clock

## 도메인 모델 아키텍처 패턴

도메인 로직, 비즈니스 로직을 어디에 둘지를 결정하는 패턴

1. **트랜잭션 스크립트** - 서비스 메소드 (PaymentService.prepare)
2. **도메인 모델** - 도메인 모델 오브젝트 (Payment)
