# Section 4: 템플릿

## 강의 내용 정리

### 템플릿 리팩토링
- 개방폐쇄원칙을 지키면서 진행
- 코드 중에서 변경이 거의 일어나지않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법
- 템플릿: 변경이 거의 일어나지않으며 일정한 패턴으로 유지되는 특성을 가진 부분
  - SW에서는 어떤 고정된 틀 안에 바꿀 수 있는 부분을 넣어서 사용하도록 만들어진 오브젝트
  - 스프링에서 사용하는 템플릿은 템플릿 메서드 패턴의 템플릿과는 약간 다르다.
- 콜백: 자유롭게 변경되는 성질을 가진 부분
- 템플릿과 콜백 형태로 만드는 이유는 여러 오브젝트에서 이를 재사용할 수 있도록 하기위함이다. 필요하다면 콜백을 변경해가면 사용한다.

<br />

** br.close를 대신 해주는 방법
- try() 안에  작성하면 BufferedReader는 나가면서 자동적으로 닫히게끔 된다.

```java
  try (BufferedReader br = new BufferedReader()){
    @@@
  }

```

<br />

### 변하는 코드와 변하지 않는 코드 분리하기 리팩토링
- 한 코드 내에서 변하는 속성과 변하지않는 속성을 구분하기 위해 로직을 정리한다.
- 방법
  1. 메서드 추출
    - 허나 재사용될 수 있는데, 클래스 내 코드로 존재하면 매번 바꿔줘야한다. 그래서,별도의 클래스로 분리
  2. 별도의 클래스로 분리
    - 구현클래스를 다양하게 확장하더라도 사용하는 쪽에서는 영향을 받지않도록 하는 “개방폐쇄 원칙”을 잘 지키도록
    - 인터페이스를 활용하여 분리
    - 허나, 분리하기만 해서는 템플릿을 사용하는 장점을 누릴 수가 없다.
  3. 콜백 활용
    - 콜백: 콜백은 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트
      - 파라미터로 전달되지만 값을 참조하기위한 것이 아니라 특정 로직을 담은 메소드를 실행시키는 것이 목적
    - 메서드 주입(=메서드 호출 주입)
      - 콜백이 템플릿의 메서드로 전달되는 과정
      - **의존 오브젝트가 메서드 호출 시점에 파라미터로 전달되는 방식**
      - 의존관계 주입의 한 종류
    - 목적: 변하지 않는 속성을 가진 코드(일정한 틀을 유지하려는)는 안에 그대로 두고, 변하는 속성을 가진 코드는 이렇게 콜백 형태로 만들어서 템플릿에 메소드 파라미터 형태로 전달
    - 람다식으로 간단히 구현 가능
  4. 템플릿 오브젝트로 분리
    - 메서드로만 분리했던 템플릿도 템플릿 오브젝트로 분리하는 작업 진행

<br />

### 템플릿/콜백은 전략 패턴의 특별한 케이스(템플릿 패턴이 아니다)
- 템플릿은 전략 패턴의 컨텍스트
- 콜백은 전략 패턴의 전략
- 템플릿/콜백은 메소드 하나만 가진 전략 인터페이스를 사용하는 전략 패턴

<br />

### 클라이언트의 책임
- 기본적으로 콜백을 생성하고 템플릿 안에 있는 메소드를 호출하는 작업
- 클라이언트니까 어떤 서비스를 이용하는 주체가 될 것
- 콜백은 클라이언트가 직접 만들거나 아니면 어디서 가져와서 전달해줘야한다.
- 콜백은 클라이언트 쪽에서 만들어지는데, 이때 클라이언트가 가지고있는 final 정보를 참고할 수 있다!

<br />

### 템플릿 빈
- 템플릿도 스프링 컨테이너에 들어가는 빈이 될 수 있다.
- 매번 인스턴스를 새로 만들면 약간의 성능 저하.
- 빈 등록 기준: 안에 상태값(업데이트 혹은 등록되는 정보)을 가지고 뭔가를 하는 경우가 아니라면 안전한 오브젝트

#### Default 콜백
- 기본적으로 제공해주는 콜백
- 콜백 지정과 콜백 디폴트 둘 다 가능하도록 디폴트 메서드와 지정 메서드 둘다 만들어준다.

<br />

<hr/>

## 느낀점
- Throws Exception은 되도록 최상단 Client까지 전달하기보다는 그냥 호출하는 쪽에서 바로 처리하는게 낫다.
- 해당 메서드 리팩토링하면서 잘 작동하는지는 해당 클래스에 메인 메서드를 만들어놓고 계속 작동해가면서 잘 작동하는지 체크한다.
- 메서드명 지을 때, 동작원리보다는 목적을 표현할 수 있는 이름을 쓰는게 더 좋다.