# section02. 오브젝트와 의존관계
오브젝트?
* 우리가 만들어내는건 클래스인데 왜 OOP라고 하지?
* 오브젝트 : 프로그램을 실행하면 그 때 만들어져서 동작하는 무엇인가
* 클래스 : 오브젝트를 만들어내기 위해 필요한거
  * 우리가 하는건 클래스를 코딩하기
  * 클래스 = 청사진
* 인스턴스 : 클래스의 인스턴스가 오브젝트다~
  * 인스턴스 = 추상적인 것에 대한 실체
  * 청사진으로 무언가를 만들어낸거


의존관계(Dependency)
* A ---> B : A가 B에 의존한다
* 클래스 사이의 의존관계(코드레벨 의존관계)
  * Client 클래스가 Supplier 클래스에 의존한다.
  * Client 클래스가 동작하려면 Supplier 클래스가 필요하다.
  * Client 클래스가 Supplier 클래스를 사용, 호출, 생성, 인스턴스화, 전송 (=사용. Client 코드 안에 Supplier 코드가 들어가있으면) 의존한다
  * Supplier 가 변경되면 Client 코드가 영향을 받는다

### 관심사의 분리(Separation of Concerns, SoC)
* 코드가 변경되는 시점이 다른 코드가 같이 있으면 안됨
  * ex) 환율 받아오는 방법이 변경되는 시점에 변경되는 코드 + 서비스하는 외환 금액을 어떻게 변경할지에 대한 서비스 로직이 변경되는 시점에 변경되는 코드 / 이 두개가 같이 있으면 안됨
* 분리하는 방법
  * 젤 쉬운건 메서드 분리 = 메서드 추출
    * 단축키
* 상속
  * 변경될 가능성이 있는 코드를 구현하지 않고 추상화만 해놓고 나중에 구현하는 방법
* 인터페이스
  * 인터페이스를 통해 다형성을 정의 가능
* 코드레벨에서의 의존관계와 런타임에서의 의존관계
  * 런타임에 어떤 클래스를 의존할것이냐? -> 예제 코드에서는 생성자에 있었음.. -> 관계설정 책임의 분리
  * 런타임 의존관계를 어디에서 설정하느냐에 따라 코드레벨 의존관계도 변경됨
  * 코드레벨 의존과 런타임 의존이 바뀌게 된다면, 런타임에 필요한 클래스를 변경해야 할 때 코드 변경이 필요함 -> 의존관계 설정 코드를 분리시키면 해결 가능
    ![image](https://github.com/youngDaLee/TIL/assets/64643665/ba840852-9596-4d6a-9a5a-7f7e96cb28bc)
* 오브젝트 팩토리
  * 클라이언트가 사용할 서비스 오브젝트를 받아옴.
  * 런타임 오브젝트 사이에 의존관계를 설정하는 책임을 오브젝트 팩토리에 넘김

### 원칙과 패턴
객체지향 설계원칙 / 객체지향 디자인패턴
* 개방 폐쇄 원칙(Open-Closed Principle OCP)
  * 클래스나 모듈은 확장에는 열려있어야 하고 변경에는 닫혀있어야 한다
  * 클래스의 기능을 추가하거나 확장할 때 클래스 코드는 변경되면 안된다
* 높은 응집도와 낮은 결합도(High Coherence and low coupling)
  * 응집도가 높다 = 하나의 모듈이 하나의 책임/관심사에 집중되어 있다. 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다. 변화가 일어날 때 해당 모듈만 수정
  * 결합도가 낮다 = 모듈 간의 상호 의존성이 낮다. 한 모듈의 변경이 다른 모듈에 영향을 미치지 않는다
* 전략패턴(Strategy Pattern)
  * 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴
  * 전략에 따라 구현 클래스를 바꿔서 사용할 수 있게 하는 패턴
* 제어의 역전(Inversion of Control)
  * 제어건 이전을 통한 제어관계 역전 - 프레임워크의 기본 동작 원리
  * 제어권이 어디에 있었느냐, 그게 어디로 이동했느냐

### 스프링 컨테이너와 의존관계 주입(Dependency Injection)
스프링 컨테이너 = IoC-DI 컨테이너
* Object Factory -> Bean Factory
  * Bean : 자바빈. 자바의 컴포넌트 오브젝트 모델. Bean=오브젝트
  * Object Factory를 BeanFactory가 참고할 수 있도록 함.
  * Object Factory -> 구성정보(Configuration): 빈클래스, 의존관계
  * 빈 오브젝트 사이의 의존관계가 생성됨
* 빈 팩토리를 생성하고, getBean으로 서비스를 받음.

### 싱글톤 레지스트리 (Singleton Registry)
스프링 빈팩토리 오브젝트를 여러 개 만들어도 같은 오브젝트를 참조..(싱글톤구조임)

### DI와 디자인패턴
Class패턴: 상속 / Object패턴: 합성
* 오브젝트 합성을 이용하는 디자인패턴을 적용할때 스프링 의존관계 주입을 사용

데코레이터 디자인 패턴
* 오브젝트에 부가적인 기능을 추가적으로 부여

### 의존성 역전 원칙(DIP, Dependency Inversion Principle)
* 상위 모듈은 하위 모듈에 의존해선 안된다. 추상화에 의해 의존해야 한다
* 추상화는 구체적인 사항에 의존해선 안된다. 구체적인 사항은 추상화에 의존해야 한다
* = 그냥 인터페이스 만들고 인터페이스를 가져와라
  * List<type> data = new ArrayList<type>(); 이런것처럼....
* 모듈 : 시스템을 쪼개놓은것
  * 대표적인 모듈: jar로 끝나는거... 
* 인터페이스 소유권의 역전
  * Seperated Interface 패턴 : 인터페이스는 어떤 패키지에 들어있어야 하는가? -> 인터페이스를 사용하고 있는 클라이언트쪽으로 인터페이스를 배치해서 DIP를 지키게 함
